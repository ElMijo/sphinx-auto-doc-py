#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os, sys
import optparse
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../'))
from sphinxdoc.helpers.mensajes import Alerta, InterfazUsuario
from sphinxdoc.sphinxdoc import SphinxDocProjecto
alert = Alerta()
ui = InterfazUsuario()
# try:
#     import sphinxdoc
# except Exception, e:
#     sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../'))
# finally:
#from ..helpers.utilitarios import obtener_mensaje

def definir_argumentos():
    """Permite Definir las opciones del comando"""
    parser = optparse.OptionParser(usage="""uso: %prog [opciones] <project path> [exclude paths, ...]""")

    return parser


def main():
    """Funci√≥n principal a ejecutarce al llamar el comando"""

    argumentos = definir_argumentos()
    (opts, args) = argumentos.parse_args()

    if not args:
        alert.warning("msj001")
    else:
        ruta_proyecto = args[0]
        if os.path.isdir(ruta_proyecto):
            proyecto = SphinxDocProjecto(ruta_proyecto)

            print proyecto.respaldar()

        else:
            alert.error("msj002",ruta_proyecto)   
        # print ui.mensaje("msj001",color='red',estilo='bold',fondo='white')
        # print ui.mensaje("msj002","jerry",color='blue',estilo='bold',fondo='white')
        #sys.exit(alert.warning("msj001"))

        #argumentos.error(obtener_mensaje("msj001"))
#     """
#     Parse and check the command line arguments.
#     """
#     parser = optparse.OptionParser(usage="""usage: %prog [options] <package path> [exclude paths, ...]

# Note: By default this script will not overwrite already created files.""")
#     parser.add_option("-n", "--doc-header", action="store", dest="header", help="Documentation Header (default=Project)", default="Project")
#     parser.add_option("-d", "--dest-dir", action="store", dest="destdir", help="Output destination directory", default="")
#     parser.add_option("-s", "--suffix", action="store", dest="suffix", help="module suffix (default=txt)", default="txt")
#     parser.add_option("-m", "--maxdepth", action="store", dest="maxdepth", help="Maximum depth of submodules to show in the TOC (default=4)", type="int", default=4)
#     parser.add_option("-r", "--dry-run", action="store_true", dest="dryrun", help="Run the script without creating the files")
#     parser.add_option("-f", "--force", action="store_true", dest="force", help="Overwrite all the files")
#     parser.add_option("-t", "--no-toc", action="store_true", dest="notoc", help="Don't create the table of content file")
#     (opts, args) = parser.parse_args()
#     if not args:
#         parser.error("package path is required.")
#     else:
#         rootpath, excludes = args[0], args[1:]
#         if os.path.isdir(rootpath):
#             # check if the output destination is a valid directory
#             if opts.destdir and os.path.isdir(opts.destdir):
#                 excludes = normalize_excludes(rootpath, excludes)
#                 recurse_tree(rootpath, excludes, opts)
#             else:
#                 print '%s is not a valid output destination directory.' % opts.destdir
#         else:
#             print '%s is not a valid directory.' % rootpath


if __name__ == '__main__':
    main()